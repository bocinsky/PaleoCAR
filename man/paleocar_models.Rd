% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/paleocar_models.R
\name{paleocar_models}
\alias{paleocar_models}
\title{Fit PaleoCAR models to a single predictand}
\usage{
paleocar_models(chronologies, predictand, calibration.years,
  reconstruction.years = NULL, verbose = F)
}
\arguments{
\item{chronologies}{A matrix of tree ring chronologies, indexed annually.
Each chronology is a column. The first column must be labeled "YEAR" and is the calendar year.}

\item{predictand}{A numeric vector of the predictand (response) variable.}

\item{calibration.years}{An integer vector of years corresponding to the layers in the \code{predictands} brick.}

\item{verbose}{Logical, display status messages during run.}

\item{prediction.years}{An optional integer vector of years for the reconstruction.
If missing, defaults to the total years present in \code{chronologies}.}
}
\value{
A named list containing
\itemize{
  \item{\code{models}  A \code{\link{data.table}} giving the fitted coefficients, LOOCV errors, and AICc values through time for each predictand.}
  \item{\code{predictand}  A numeric vector of the predictand, as provided.}
  \item{\code{predictor.matrix}  A matrix of predictors for calibration; \code{chronologies} cropped to \code{calibration.years}.}
  \item{\code{reconstruction.matrix}  A matrix of predictors for reconstruction; \code{chronologies} cropped to \code{prediction.years}, or all of \code{chronologies} if \code{prediction.years==NULL}.}
}
}
\description{
This is the primary function for fitting PaleoCAR models to a single predictand using
a uniform set of predictors (tree-ring chronologies). \code{\link{carscore}s} are calculated for 
each predictor, and models are calculated by adding predictors stepwise to an ordinary least-squares
linear model using the \code{\link{lm}} function. Model selection is performed by minizing corrected AIC.
This occurs for every unique set of available predictors through time.
}
\details{
See \code{\link{paleoCAR_models_batch}} for a batch algorithm that is more efficient (though more 
computationally complicated) than the algorithm provided here.
}

